# 静态链表的定义

Q：静态链表的图示？

A：

![image-20201208161819191](https://gitee.com/llillz/images/raw/master/image-20201208161819191.png)



**静态链表的特点：**

-   静态链表的功能和单链表类似，但是区别在于结点在内存中是否连续存储：静态链表的结点在内存中连续存放
-   静态链表是由数组实现的链表：因此容量不可变
-   结点的逻辑顺序由每个结点中的“游标”指示（即充当指针的作用，但本质上和指针不同），**0号结点（游标为0）表示头结点**（静态链表和顺序表不同，后者元素的逻辑顺序由物理存放顺序确定）
-   **游标为-1表示到达表尾**



---

Q：如何计算静态链表的存放地址？（游标与结点实际存放地址的映射关系）

A：设数据元素4B、游标4B，起始地址是 addr，则游标



---

**代码实现：**

>   C语言中有2种等价的写法，如下所示

```c
#define MAXSIZE 10 // 静态链表最大长度
typedef struct node // 定义静态链表
{
    int data;
    int next; // 游标
} SLinkList[MAXSIZE];
```

等价于

```c
#define MAXSIZE 10 // 静态链表最大长度
struct node // 定义静态链表
{
    int data;
    int next; // 游标
} ;
typedef struct node SLinkList[MAXSIZE]; 
```



上述两种写法都定义了一个静态链表 `SLinkList`，声明时的写法如下：

```c
SLinkList a; // 声明了一个长度为MAXSIZE的静态链表a
```



下面的测试验证了不同的写法效果是一样的：

![image-20201208164211714](https://gitee.com/llillz/images/raw/master/image-20201208164211714.png)



**注**：无论是哪种定义方法，在声明时都可以通过一条语句 `SLinkList a` 声明静态链表，强调了静态链表的“链表”特点而非“数组”特点，有助于提高代码可读性。



# 初始化

在定义的基础上让位序为1的结点作为头结点（游标设为-1）：

```c
a[0] = -1
把其他结点的next设置为一个除了-1外的特殊值，如-2，这可以表示该结点是空的 // 对于插入操作很有意义
```



# 查找（指定位序的结点）

方法：从头结点出发，依次遍历结点



注：区分位序和数组下标的含义

-   位序：元素的在逻辑上的顺序（从1开始）
-   数组下标/索引：元素的物理顺序（一般从0开始）
-   在静态链表中，位序和数组下标是没有关系的（而顺序表中，`位序=数组下标+1`）！



# 插入（位序为i的结点）

算法：

1.  找到空的结点，存入数据元素（一般用遍历） // O()
2.  从头结点开始找到位序为i-1的结点
3.  修改位序为i-1结点的next
4.  修改位序为i结点的next



# 删除（位序为i的结点）

算法：

1.  从头结点开始找到位序为i-1的结点
2.  修改位序为i-1结点的next
3.  修改位序为i结点的next为特殊值（表示结点为空）



# 静态链表的应用

![image-20201208170721582](https://gitee.com/llillz/images/raw/master/image-20201208170721582.png)