# 广度优先遍历

## 思想

> 图本就是一般化的树，图的广度优先遍历可以参考树的层序遍历思想。

广度优先遍历（Breadth-First-Search，BFS）的主要思想：

1. 找到与顶点相邻的所有顶点：体现了“广度”
2. 标记已经访问过的顶点：避免重复访问结点。
3. 遍历时借助辅助队列：先访问结点，访问后将其入队。对头元素出队时，将该结点的相邻的未访问的结点入队。
4. 要考虑非连通图的情况



## 代码实现

![image-20201224142448546](https://gitee.com/llillz/images/raw/master/image-20201224142448546.png)



注：同一个图的邻接矩阵表示方法唯一，故广度优先遍历序列也唯一；同一个图的邻接表表示方法不唯一，故广度优先遍历序列也不唯一。



## 效率分析

空间复杂度：

![image-20201224142627620](https://gitee.com/llillz/images/raw/master/image-20201224142627620.png)



时间复杂度：

> 时间开销来自于访问顶点以及各条边。

![image-20201224143611666](https://gitee.com/llillz/images/raw/master/image-20201224143611666.png)



## 广度优先生成树

![image-20201224143945578](https://gitee.com/llillz/images/raw/master/image-20201224143945578.png)



## 广度优先生成森林

![image-20201224144034651](https://gitee.com/llillz/images/raw/master/image-20201224144034651.png)

# 深度优先遍历

## 思想

> 图本就是一般化的树，图的深度优先遍历可以参考树的深度遍历（确切说是树的先根遍历）思想。

深度优先遍历（Depth-First-Search，DFS）的主要思想：

1. 访问图的第一个结点
2. 递归的访问图的相邻结点，并标记已经访问过的顶点：避免重复访问结点
3. 递归需要借助辅助堆栈
4. 要考虑非连通图的情况



---

**Q：如何判断一个图是否连通？**

A：深度优先遍历一个图，如果从起始顶点开始能遍历完所有结点，则说明图连通。

## 代码实现

![image-20201224145229672](https://gitee.com/llillz/images/raw/master/image-20201224145229672.png)





## 效率分析

空间复杂度：

![image-20201224145511095](https://gitee.com/llillz/images/raw/master/image-20201224145511095.png)



时间复杂度：

> 深度优先和广度优先的时间复杂度一样。

![image-20201224145625107](https://gitee.com/llillz/images/raw/master/image-20201224145625107.png)



## 深度优先遍历序列

![image-20201224145947069](https://gitee.com/llillz/images/raw/master/image-20201224145947069.png)

注：同一个图的邻接矩阵表示方法唯一，故广度优先遍历序列也唯一；同一个图的邻接表表示方法不唯一，故广度优先遍历序列也不唯一。



## 深度优先生成树&深度优先生成森林

类似广度优先生成树&广度优先生成森林。